<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Linear Regression Demo</title>
    <style>
        canvas { border: 1px solid black; }
        .controls { margin: 10px 0; }
        pre { background: #f4f4f4; padding: 10px; border-radius: 5px; }
    </style>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css">
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body);
        });
    </script>
</head>
<body>
    <h2>Simple Linear Regression Demo</h2>
    <canvas id="plot" width="500" height="400"></canvas>
    <div class="controls">
        <label>Slope (m): <input type="range" id="slope" min="-2" max="2" step="0.01" value="1"></label>
        <label>Intercept (b): <input type="range" id="intercept" min="-100" max="100" step="1" value="0"></label>
    </div>
    <p>Mean Squared Error: <span id="mse">0</span></p>
    <button onclick="generatePoints()">Regenerate Points</button>
    <h3>Finding Optimal Slope & Intercept</h3>
    <p>The optimal slope (m) and intercept (b) can be found using the normal equation:</p>
    <p>In matrix form, the linear regression model is:</p>
    <p>\[ Y = X B + \varepsilon \]</p>
    <p>Where:</p>
    <ul>
        <li>\( Y \) is the vector of observed values</li>
        <li>\( X \) is the design matrix with a column of ones for the intercept and a column for the predictor variable</li>
        <li>\( B \) is the vector of parameters (intercept and slope)</li>
        <li>\( \varepsilon \) is the error term</li>
    </ul>
    <p>The least squares solution is obtained by solving:</p>
    <p>\[ B = (X^T X)^{-1} X^T Y \]</p>
    <h3>Example Calculation</h3>
    <p>Given the dataset:</p>
    <pre>
        x = [1, 2, 3]
        y = [2, 2.8, 3.6]
    </pre>
    <p>The design matrix \( X \) is:</p>
    <p>\[ X = \begin{bmatrix} 1 & 1 \\ 1 & 2 \\ 1 & 3 \end{bmatrix} \]</p>
    <p>The normal equation components:</p>
    <p>\[ X^T X = \begin{bmatrix} 3 & 6 \\ 6 & 14 \end{bmatrix} \]</p>
    <p>\[ X^T Y = \begin{bmatrix} 8.4 \\ 18.8 \end{bmatrix} \]</p>
    <p>Solving for \( B \):</p>
    <p>\[ B = \begin{bmatrix} 1.2 \\ 0.8 \end{bmatrix} \]</p>
    <button onclick="computeOptimalFit()">Find Optimal Fit</button>
    
    <script>
        const canvas = document.getElementById("plot");
        const ctx = canvas.getContext("2d");
        const slopeSlider = document.getElementById("slope");
        const interceptSlider = document.getElementById("intercept");
        const mseDisplay = document.getElementById("mse");
        let points = [];

        function generatePoints() {
            points = [];
            let trueSlope = 1.2;
            let trueIntercept = 30*Math.random();
            let noiseAmplitude = 10*Math.random()+10;
            for (let i = 0; i < 50; i++) {
                let x = i * 10;
                let noise = noiseAmplitude*(Math.random() - 0.5) * 40; // Adding some noise
                let y = trueSlope * x + trueIntercept + noise;
                points.push({ x, y });
            }
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "black";
            ctx.beginPath();
            ctx.moveTo(50, 350);
            ctx.lineTo(450, 350);
            ctx.moveTo(50, 350);
            ctx.lineTo(50, 50);
            ctx.stroke();
            
            ctx.fillStyle = "blue";
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
            drawLine();
        }

        function drawLine() {
            let m = parseFloat(slopeSlider.value);
            let b = parseFloat(interceptSlider.value);
            let x1 = 0;
            let y1 = m * x1 + b;
            let x2 = 500;
            let y2 = m * x2 + b;
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            computeMSE(m, b);
        }

        function computeMSE(m, b) {
            let error = points.reduce((sum, p) => {
                let predictedY = m * p.x + b;
                return sum + (p.y - predictedY) ** 2;
            }, 0) / points.length;
            mseDisplay.innerText = error.toFixed(2);
        }

        function computeOptimalFit() {
            let meanX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            let meanY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
            let num = points.reduce((sum, p) => sum + (p.x - meanX) * (p.y - meanY), 0);
            let den = points.reduce((sum, p) => sum + (p.x - meanX) ** 2, 0);
            let optimalM = num / den;
            let optimalB = meanY - optimalM * meanX;
            slopeSlider.value = optimalM;
            interceptSlider.value = optimalB;
            draw();
        }
        
        slopeSlider.addEventListener("input", draw);
        interceptSlider.addEventListener("input", draw);
        generatePoints();
    </script>
</body>
</html>
